% Конструкторы

Есть только один способ создать экземпляр пользовательского типа: дать ему имя,
и инициализировать сразу все его поля:

```rust
struct Foo {
    a: u8,
    b: u32,
    c: bool,
}

enum Bar {
    X(u32),
    Y(bool),
}

struct Unit;

let foo = Foo { a: 0, b: 1, c: false };
let bar = Bar::X(0);
let empty = Unit;
```

Вот и все. Каждый любой другой способ создания экземпляра типа - это только
вызов сахарной функции, которая делает какие-то вещи и в конечном итоге
вызывает Один Единственный Конструктор.

В отличие от C++, Rust не поставляется с убийственным набором конструкторов. В
нем нет Copy, Default, Assignment, Move или еще каких-либо конструкторов. Этому
множество причин, но основной является философия Rust - *быть явным*.

Конструкторы Move бессмысленны в Rust, потому что мы не позволяем типам
"заботиться" о своем расположении в памяти. Каждый тип должен быть готов быть
скопированным в другое место в памяти. Это означает, что чистые на-стеке-но-все-
еще-перемещаемые навязчивые связные списки просто нельзя встретить в Rust
(безопасном).

Конструкторы Assignment и Copy также не существуют, потому что семантика
перемещения - это единственная семантика в Rust. В большинстве случаев `x = y`
просто перемещает биты y в переменную x. Rust дает две возможности для
предоставления copy-ориентированной семантики C++: `Copy` и `Clone`. Clone - это
наш духовный эквивалент конструктора copy, но он никогда не вызовется неявно.
Вам нужно явно вызвать `clone` у элемента, который вы хотите клонировать. Copy -
особый случай Clone, у которого реализацией является просто "скопируй биты".
Типы Copy *неявно* клонируются во время перемещения, но из определения Copy -
это просто означает, не считать старую копию неинициализированной - то есть, это
пустая операция.

Хоть Rust и предоставляет типаж `Default` для определения духовного эквивалента
конструктора по умолчанию, его очень редко используют. Все из-за того, что
переменные [неявно не инициализируются][uninit]. Default в основном полезен
только для обобщенного программирования. В конкретном контексте, тип предоставит
статический метод `new` для любого типа конструкторов "по умолчанию". Здесь нет
связи с `new` из других языков, и особого смысла это слово тоже не несет. Это
просто соглашение именования.

TODO: рассказать о "размещении new"?

[uninit]: uninitialized.html
