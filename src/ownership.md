% Владение и время жизни

Владение - это пробивная особенность Rust. Оно позволяет Rust быть полностью
безопасным по памяти и эффективным, избегая сборки мусора. Перед тем как
детально разобрать систему владения, мы объясним предпосылки такого дизайна.

Мы подразумеваем, что вы принимаете, что сборщик мусора - не всегда самое
оптимальное решение, и что желательно в некоторых случаях управлять памятью
вручную. Если вы это не принимаете, возможно вам стоит поискать другой язык?

Несмотря на ваши чувства к GC, он является *огромным* благом, позволяющим делать
код безопасным. Вам не нужно волноваться никогда, что некоторые вещи удалятся
*слишком рано* (хотя нужно ли вам по-прежнему иметь ссылку на них в этом случае
это другой вопрос...). Это распространенная проблема, с которой приходится иметь
дело программам на C и C++. Предположим, что каждый из нас, столкнувшись с
языком без GC, совершал такую ошибку:

```rust,ignore
fn as_str(data: &u32) -> &str {
    // compute the string
    let s = format!("{}", data);

    // О НЕТ! Мы возвращаем ссылку на что-то, 
    // что существует только в этой функции!
    // Висячий указатель! Используется после освобождения! Увы и ах!
    // (Rust не компилирует этот код)
    &s
}
```

Вот, что именно должна решать система владения в Rust. Rust знает область
видимости, в которой живет `&s`, и поэтому не даст выйти из нее. Это простой
случай, который даже компилятор C сможет правдоподобно поймать. Все становится
сложнее, когда код растет и указатели передаются по различным функциям. В
конечном счете, компилятор C сломается и не сможет выполнить анализ областей
видимости, чтобы доказать, что ваш код сломан. Ему придется заставить себя
принять вашу программу, предполагая что она правильна.

Это никогда не произойдет в Rust. Программисту нужно доказать компилятору, что
ничего не сломается.

Конечно, рассказ о владении в Rust гораздо сложней, чем просто проверка, что
ссылка не выходит за область видимости того, на что она ссылается. Потому что
доказать, что гарантированные указатели всегда правильны, гораздо сложнее, чем
это. Например, в этом коде

```rust,ignore
let mut data = vec![1, 2, 3];
// получаем внутреннюю ссылку
let x = &data[0];

// О НЕТ! `push` заставляет пересчитать занимаемое место `data`.
// Висячий указатель! Используется после освобождения! Увы и ах!
// (Rust не компилирует этот код)
data.push(4);

println!("{}", x);
```

обычный анализ областей видимости не сможет поймать эту ошибку, потому что
`data` на самом деле живет столько, сколько надо. Но она *поменялась* в то
время, когда у нас есть ссылка на нее. Вот поэтому Rust требует, чтобы любые
ссылки замораживали объекты, на которые ссылаются, и владельцев этих объектов.

