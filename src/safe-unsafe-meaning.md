% Как взаимодействуют Безопасный и Небезопасный код

Итак, какие отношения между Безопасным и Небезопасным Rust? Как они
взаимодействуют?

Rust осуществляет разделение между Безопасным и Небезопасным Rust ключевым
словом `unsafe`, которое можно трактовать как *интерфейс внешних функций
(foreign function interface)* (FFI) между Безопасным и Небезопасным Rust. Это
магия, благодаря которой можно сказать, что Безопасный Rust - действительно
безопасен: вся работа со страшными небезопасными битами отводится исключительно
FFI, *как-будто с любым другим безопасным языком*.

Но из-за того, что один язык, получается, входит в другой, их можно спокойно
смешивать, обозначая границы между ними ключевым словом `unsafe`. Не надо писать
заголовочные файлы, инициализировать среду исполнения или какую-либо другую
рутину по обработке FFI.

Сегодня есть несколько мест, где может появиться `unsafe` в Rust, которые грубо
можно разделить на две категории:

* У вас есть непроверенные контракты. Чтобы убедиться, что вы поняли, что
имеется ввиду, я рекомендую писать `unsafe` в следующих случаях:     
  * Перед функциями `unsafe` показывает, что ее вызывать небезопасно. 
  Пользователи должны смотреть документацию, чтобы определить, что это значит,
   и написать `unsafe`, чтобы подтвердить, что они знают об опасности.     
  * Перед объявлением типажей `unsafe` показывает, что *реализация* типажа 
  является небезопасной операцией, потому что у него есть контракты, которым 
  другой небезопасный код имеет право слепо доверять. (Больше об этом ниже.)

* Я заявляю, в меру своих знаний, что придерживаюсь следующей логики применения 
непроверенных контрактов:
  * В реализации типажей `unsafe` показывает, что соблюдается контракт типажа
`unsafe`.
  * В блоках `unsafe` показывает, что любая работа с небезопасными операциями 
  должна обрабатываться внутри, и, следовательно, родительская функция 
  безопасна.

Также есть флаг `#[unsafe_no_drop_flag]`, являющийся особым случаем,
присутствующим по историческим причинам и находящимся на пути к выпиливанию.
Смотри раздел [drop flags] для уточнения.

Примеры небезопасных функций:

* `slice::get_unchecked` выполняет непроверенное индексирование, позволяющее
свободно нарушить безопасность памяти. 
* любой сырой указатель на тип фиксированного размера обладает внутренним 
методом `offset`, который вызывает Неопределенное Поведение, если находится 
"вне границ", определяемых LLVM. 
* `mem::transmute` интерпретирует значение полученного типа как другого типа, 
самовольно обходя безопасность типов. (смотри [conversions] для уточнения) 
* Все функции FFI являются `unsafe`, потому что могут выполнять произвольные 
сценарии. "С" часто является очевидным виновником этого, но вообще-то любой язык
 может сделать то, от чего Rust будет не в восторге.

В Rust 1.0 есть ровно два небезопасных типажа:

* `Send` - это маркерный типаж (у него нет своего API), который обещает, что его
реализации можно безопасно посылать (перемещать) в другой поток.
* `Sync` - это маркерный типаж, который обещает, что потоки могут безопасно 
делить его реализацию между собой, используя общую ссылку на нее.

Необходимость в небезопасных типаж кроется в основных свойствах безопасного
кода:

**Каким бы убогим ни был Безопасный код, он не сможет вызвать Неопределенное
поведение.

Это означает, что Небезопасный Rust, **королевский авангард против 
Неопределенного поведения**, *супер параноидально* относится к обобщенному 
безопасному коду. Объясняя яснее, Небезопасный Rust абсолютно доверяет 
конкретному безопасному коду. Остальной код вырождается в бесконечные спирали 
параноидального отчаяния для него. В частности, обычно нормальным считается 
доверять корректности стандартной библиотеки. `std` - это полезное расширение 
языка, вам, действительно, следует доверять ему. Если `std` нарушает свои 
гарантии, тогда это точно ошибка в языке.

Тем не менее, лучше минимизировать напрасные надежды на железобетонность
безопасного кода. Ошибки случаются! Конечно, я должен подтвердить, что надо
беспокоиться только за Небезопасный код. Безопасный код может слепо верить
всему, что не нарушает безопасность памяти.

С другой стороны, безопасные типажи могут свободно объявлять произвольные
контракты, именно, потому что их реализация безопасна, небезопасный код же не
может доверять тому, что эти контракты будут на самом деле соблюдаться. Это
отличается от какого-то конкретного случая, потому что *любой человек* может
реализовать интерфейс, как он хочет. В этом и состоит фундаментальная разница,
доверять ли правильности конкретного участка кода или доверять правильности
*любого кода, который будет когда либо написан*.

Например, в Rust есть типажи `PartialOrd` и `Ord`, нужные для того, чтобы можно
было отличить типы, которые можно "только" сравнивать, от тех, которые в
действительности поддерживают упорядочивание. В большинстве своем, каждое API,
которое хочет работать со сравнимыми данными, хочет иметь `Ord`. Например,
упорядоченный словарь BTreeMap *не имеет никакого смысла* создавать для частично
упорядоченных данных. Если вы объявите, что тип реализует `Ord`, но не
предоставите данные в правильном порядке, BTreeMap *сядет в лужу* и начнет
делать с собой разные плохие вещи. Вставленные данные будет уже невозможно
найти!

Но это еще нормально. BTreeMap безопасен, поэтому он гарантирует, что даже если
вы дадите ему полностью несортированную реализацию, он будет все равно делать
что-то *безопасное*. Он не начнет загружать неинициализированную или
невыделенную память. На самом деле, BTreeMap не потеряет даже ваши данные. После
его удаления, все деструкторы будут вызваны успешно! Ура!

Однако BTreeMap реализован с использованием маленькой щепотки Небезопасного Rust
(как и большинство коллекций). Это означает - не всегда правдиво будет
утверждать, что реализация плохого порядка заставит вести себя BTreeMap
безопасно. BTreeMap не должен полагаться на порядок, *ставя под угрозу
безопасность*. Порядок предоставляется безопасным кодом, а безопасность это не
то, за соблюдение чего безопасный код отвечает.

Но правда было бы здорово, если бы небезопасный код мог бы в *каких-нибудь
местах* доверять контрактам типажа? Эта проблема, которой занимаются
небезопасные типажи: помечая небезопасность реализации *самого типажа*,
небезопасный код может доверять реализациям контракта типажа. Хотя она может и
не быть правильной во всех произвольных случаях.

Например, имея гипотетический типаж UnsafeOrd, технически будет правильна такая
реализация:

```rust
# use std::cmp::Ordering;
# struct MyType;
# unsafe trait UnsafeOrd { fn cmp(&self, other: &Self) -> Ordering; }
unsafe impl UnsafeOrd for MyType {
    fn cmp(&self, other: &Self) -> Ordering {
        Ordering::Equal
    }
}
```

Но возможно это совсем не та реализация, которая вам нужна.

Rust традиционно избегает делать типажи, по умолчанию, небезопасными, потом что
это сделало бы ее повсеместной, что не желательно. Send и Sync небезопасны,
потому что потокобезопасность - *фундаментальное свойство*, от которого
небезопасный код даже не может попытаться защититься, также как он не может
защититься от плохой реализации порядка из примера выше. Единственный способ как
можно  защититься от потоконебезопасности - *не использовать потоки вообще*.
Сделать каждую загрузку и сохранение атомарными тоже недостаточно, потому что
сложные инварианты могут существовать на непересекающихся областях памяти.
Например, указатель и размер у Vec должны быть синхронизированы.

Даже такая парадигма параллельности, которая традиционно считается Абсолютно
Безопасной, как обмен сообщениями, неявно опирается на потокобезопасность --
действительно ли вы используете обмен сообщениями, если вы передаете указатель?
Для Send и Sync, таким образом, требуется фундаментальный уровень доверия,
который Безопасный код не может предоставить, поэтому их реализацию необходимо
сделать небезопасной. Чтобы избежать проникающую везде небезопасность, которая
возникнет вследствие этого, Send (или Sync) автоматически выводится для всех
типов, состоящих из значений только Send (или Sync) типов. 99% типов являются
Send и Sync, и 99% из них никогда не сообщают об этом (оставшийся 1% это по
большей части примитивы синхронизации).




[drop flags]: drop-flags.html
[conversions]: conversions.html
