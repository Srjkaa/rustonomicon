% Безопасность Исключений

Хоть программы и должны использовать редко размотку, есть много кода, который
*может* запаниковать. Если вы делаете unwrap у None, индекс вне границ массива
или делите на 0, ваша программа вызовет панику. В режиме отладки каждая
арифметическая операция может вызвать панику при переполнении. Пока вы не будете
очень аккуратным и не будете строго контролировать, что код запускает, вам нужно
быть готовым к этому.

Быть готовым к размотке часто относится к *безопасности исключений* в более
широком мире программирования. В Rust присутствуют два уровня безопасности
исключений, с которыми можно столкнуться:

* В небезопасном коде мы *должны* соблюдать безопасность исключений с той точки
 зрения, что не позволять нарушать безопасности памяти. Назовем это 
 *минимальной* безопасностью исключений.

* В безопасном коде *необходимо* соблюдать безопасность исключений с той точки 
зрения, что ваша программа должна работать правильно. Назовем это 
*максимальной* безопасностью исключений.

Как и в случае с другими случаями в Rust, небезопасный код должен быть готов
иметь дело с плохим безопасным кодом, когда дело доходит до размотки. Код,
который временно создает неправильные состояния, должен заботиться, чтобы не
вызвалась паника в этом состоянии. В общем это означает, что необходимо
гарантировать, что только не вызывающий панику код выполняется пока все
находится в неправильном состоянии или необходимо создать охранника, который
почистит это состояние в случае паники. Это не обязательно означает, что
состояние во время паники должно быть полностью вразумительным. Мы должны только
гарантировать, что это *безопасное* состояние.

Большинство небезопасного кода является листовидным, и поэтому легко делается
безопасным по исключениям. Он контролирует весь запускаемый код и большинство
этого кода не может вызвать панику. Однако для небезопасного кода работа с
массивами временно неинициализированных данных во время постоянно вызываемого
кода-обработчика этих данных не является чем-то необычным. Такой код должен быть
аккуратным и подразумевать безопасность исключений.





## Vec::push_all

`Vec::push_all` это временный хак расширения Vec срезом надежно и
эффективно, не используя специализацию. Вот простая реализация:

```rust,ignore
impl<T: Clone> Vec<T> {
    fn push_all(&mut self, to_push: &[T]) {
        self.reserve(to_push.len());
        unsafe {
            // не может переполниться, потому что мы только что зарезервировали его
            self.set_len(self.len() + to_push.len());

            for (i, x) in to_push.iter().enumerate() {
                self.ptr().offset(i as isize).write(x.clone());
            }
        }
    }
}
```

Мы обходим `push` для избежания избыточных проверок размера и `len` Vec, которые
мы точно знаем. Логика абсолютно правильно, кроме маленькой проблемы: он не
безопасен по исключениям! `set_len`, `offset` и `write` - все правильны; `clone`
- бомба, которую мы просмотрели.

Clone абсолютно не контролируется нами и свободно может вызвать панику. Если так
будет, наша функция выйдет раньше времени и длина Vec будет слишком большой.
Если к нему обратятся или удалят его, неинициализированная память будет
прочтена!

Исправление тут очень простое. Если мы хотим гарантировать, что значения,
которые мы *действительно* клонировали, удаляются, мы можем устанавливать `len`
на каждом цикле итераций. Если мы просто хотим гарантировать, что не будет
прочтена неинициализированная память, мы можем установить `len` после цикла.





## BinaryHeap::sift_up

Поднять наверх элемент в куче - немного сложней, чем расширить Vec. Псевдокод
следующий:

```text
bubble_up(heap, index):
    while index != 0 && heap[index] < heap[parent(index)]:
        heap.swap(index, parent(index))
        index = parent(index)

```

Литеральная транскрипция этого кода в Rust абсолютно нормальна, но
характеристики производительности раздражают: элемент `self` снова и снова
бесполезно меняется местами. Исправим на следующее:

```text
bubble_up(heap, index):
    let elem = heap[index]
    while index != 0 && element < heap[parent(index)]:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
```

Код гарантирует, что каждый элемент копируется максимально малое количество раз
(на самом деле этот элемент будет копироваться дважды в общем случае). Однако
теперь появились проблемы с безопасностью исключений! Все время существуют две
копии одного значения. Если вызовется паника в функции, что-то будет дважды
удалено. К сожалению, у также нет полного контроля над кодом: сравнение
определяется пользователем!

В отличие от Vec исправление здесь не такое простое. Одним вариантом будет
разбить пользовательский код и небезопасный код на две отдельные фазы:

```text
bubble_up(heap, index):
    let end_index = index;
    while end_index != 0 && heap[end_index] < heap[parent(end_index)]:
        end_index = parent(end_index)

    let elem = heap[index]
    while index != end_index:
        heap[index] = heap[parent(index)]
        index = parent(index)
    heap[index] = elem
```

Если ломается пользовательский код, это больше не проблема, потому что мы еще не
меняли состояние кучи. Когда начинаем работать с кучей, мы работаем только с
данными и функциями, которым доверяем, поэтому не надо беспокоится о панике.

Возможно вы недовольны таким дизайном. Конечно, это обман! И нам придется
выполнить сложное прохождение кучи *дважды*! Ладно, давайте стиснем зубы.
Давайте *по-настоящему* смешаем ненадежный и небезопасный код вместе.

Если б у Rust были `try` и `finally` как в Java, мы могли бы сделать следующее:

```text
bubble_up(heap, index):
    let elem = heap[index]
    try:
        while index != 0 && element < heap[parent(index)]:
            heap[index] = heap[parent(index)]
            index = parent(index)
    finally:
        heap[index] = elem
```

Базовая идея проста: если сравнение вызывает панику, мы просто бросаем
потерянный элемент по логически неинициализированному индексу и
катапультируемся. Каждый, кто посмотрит на кучу, увидит потенциально
*несогласованную* кучу, но по крайней мере не будет двойного удаления! Если
алгоритм завершится нормально, то эта операция точно совпадет с тем, как мы
закончим, независимо от этого.

Жалко, что у Rust нет такой конструкции, поэтому нам придется накатать свою!
Одним из способов сделать это - хранить состояние алгоритма в отдельной
структуре и создать деструктор для логики "finally". Независимо от того,
вызовется паника или нет, этот деструктор выполнится и почистит все за нами.

```rust,ignore
struct Hole<'a, T: 'a> {
    data: &'a mut [T],
    /// `elt` всегда `Some` от создания до удаления.
    elt: Option<T>,
    pos: usize,
}

impl<'a, T> Hole<'a, T> {
    fn new(data: &'a mut [T], pos: usize) -> Self {
        unsafe {
            let elt = ptr::read(&data[pos]);
            Hole {
                data: data,
                elt: Some(elt),
                pos: pos,
            }
        }
    }

    fn pos(&self) -> usize { self.pos }

    fn removed(&self) -> &T { self.elt.as_ref().unwrap() }

    unsafe fn get(&self, index: usize) -> &T { &self.data[index] }

    unsafe fn move_to(&mut self, index: usize) {
        let index_ptr: *const _ = &self.data[index];
        let hole_ptr = &mut self.data[self.pos];
        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);
        self.pos = index;
    }
}

impl<'a, T> Drop for Hole<'a, T> {
    fn drop(&mut self) {
        // fill the hole again
        unsafe {
            let pos = self.pos;
            ptr::write(&mut self.data[pos], self.elt.take().unwrap());
        }
    }
}

impl<T: Ord> BinaryHeap<T> {
    fn sift_up(&mut self, pos: usize) {
        unsafe {
            // Take out the value at `pos` and create a hole.
            let mut hole = Hole::new(&mut self.data, pos);

            while hole.pos() != 0 {
                let parent = parent(hole.pos());
                if hole.removed() <= hole.get(parent) { break }
                hole.move_to(parent);
            }
            // Hole будет безусловно заполнена здесь; с паникой или нет!
        }
    }
}
```
