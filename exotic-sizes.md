% Типы экзотического размера

Большинство времени мы думаем в терминах типов фиксированного положительного
размера. Однако, все далеко не всегда так.


# Типы динамического размера (DSTs)

Rust на самом деле поддерживает Типы динамического размера (DSTs): типы без
статически известного размера или выравнивания. На поверхности, все это кажется
бессмысленным: Rust *должен* знать размер и выравнивание чего-либо, для того
чтобы корректно с этим работать! Смотря под этим углом, DSTs - это не нормальные
типы. Из-за отсутствия статически известного размера, они могут скрываться
только за указателем особого типа. Любой указатель на DST вследствие этого
становится *толстым*, состоящим из указателя и информации, которая "дополняет"
его (подробнее об этом ниже).

Язык предлагает два главных DSTs: типажи-объекты и срезы.

Типаж-объект представляет тип, реализующий указанный типаж. Точный оригинальный
тип *затирается* во время исполнения на виртуальную таблицу, содержащую
всю информацию, необходимую для использования типа. Эту информация дополняется
тем, из чего состоит типаж-объект: указатель на его виртуальную таблицу.

Срез - это просто отображение в какое-то подходящее хранилище -- обычно в массив
или `Vec`. Информация, которая дополняет срез - это просто количество элементов,
на которые он указывает.

Структуры вообще-то могут хранить один DST прямо в своем последнем поле, но это
делает их также DST:

```rust
// Невозможно хранить напрямую в стеке
struct Foo {
    info: u32,
    data: [u8],
}
```

**Внимание: [Что касается Rust 1.0, структурные DST ломаются, если последнее
поле имеет переменную позицию, основанную на его выравнивании][dst-issue].**



# Типы с нулевым размером (ZSTs)

Rust на самом деле позволяет объявлять типы, которые не занимают места:

```rust
struct Foo; // Нет полей = нет размера

// У каждого поля нет размера  = нет размера
struct Baz {
    foo: Foo,
    qux: (),      // у пустого кортежа нет размера
    baz: [u8; 0], // у пустого массива нет размера
}
```

Сами по себе Типы с нулевым размером (ZSTs) по очевидным причинам довольно
бесполезны. Но, как и с другими любопытными решениями по выделению памяти в
Rust, их потенциал выражается в контексте обобщений: Rust очень хорошо понимает,
что любые операции, которые создают или хранят ZST, могут быть заменены на no-
op. Прежде всего хранение их вообще не имеет смысла -- они не занимают никакого
места. Дальше, есть только одно значение этого типа, поэтому все, что загружает
их, может создать их из эфира -- что тоже является no-op из-за того, что они
опять же не занимают никакого места.

Одним из самых важных примеров являются Наборы и Словари. Имея `Map<Key,
Value>`, часто реализуют `Set<Key>` в качестве тонкой оболочки вокруг `Map<Key,
БесполезныйМусор>`. Многие языки заставляют выделять место под БесполезныйМусор
и вынудят обрабатывать его хранение и загрузку только для того, чтобы потом
выкинуть его. Доказывая, что ненужность этих действий очень сложно анализировать
компилятору.

Однако в Rust мы можем просто сказать `Set<Key> = Map<Key, ()>`. Так Rust
понимает, что любая загрузка и хранение бесполезны, и выделение памяти не нужно.
В результате получаем, что мономорфный код - это обычная частая реализация
HashSet без каких бы накладных расходов по поддержке значений.

Безопасному коду не надо волноваться о ZST, но *небезопасный* должен быть очень
аккуратен с последствиями, которые влекут типы без размера. В частности,
смещение указателей это no-ops, и стандартный распределитель памяти (включая
jemalloc, который использует по умолчанию Rust) может вернуть `nullptr` если
запрашивается положение в памяти типа с нулевым размером, из-за того что они
неотличимы в памяти.



# Пустые типы

Rust также позволяет объявлять типы, *экземпляр которых нельзя создать*. О них
можно говорить только на уровне типов, но никогда на уровне значений. Пустые
типы можно объявить указав перечисление без вариантов:

```rust
enum Void {} // Вариантов нет = Пусто
```

Пустые типы еще более маргинальны чем ZST. Единственное назначение типа Void из
примера выше - недостижимость уровня-типа. Например, предположим API должно
возвращать Result в общем случае, но какой-то конкретный случай на самом деле
никогда не возвращает ошибку. Здесь можно сообщить об этом на уровне типа,
возвращая `Result<T, Void>`. Пользователи этого API могут спокойно делать unwrap
такого Result, зная что *статически невозможно* получить `Err` в значении, так
как пришлось бы предоставлять значение типа `Void`.

В принципе, Rust мог бы выполнять некоторый интересный анализ и оптимизацию,
зная все это. Например, `Result<T, Void>` мог бы быть представлен просто как
`T`, потому что случая `Err` на самом деле не существует. Код ниже *мог* бы
компилироваться:

```rust,ignore
enum Void {}

let res: Result<u32, Void> = Ok(0);

// Err не существует, поэтому Ok полностью безошибочен.
let Ok(num) = res;
```

Но на текущий момент ни один из этих трюков не работает, поэтому все, что дает
вам тип Void - это возможность быть уверенным в том, что некоторые ситуации
*статически невозможны*.

И последний тонкий момент о пустых типах - сырые указатели на них создавать
можно и это считается правильным, но разыменование таких указателей приведет к
Неопределенному поведению, потому что никакого смысла в этом нет. Вот и все, вы
можете смоделировать тип C `void *` как `*const Void`, но это не обязательно
даст выигрыш по сравнению с использованием, например, `*const ()`, который
*безопасен* по отношению к случайному разыменованию.


[dst-issue]: https://github.com/rust-lang/rust/issues/26403
