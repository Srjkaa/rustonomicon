% Встреча безопасного и небезопасного

Программисты безопасных "высокоуровневых" языков встречаются с фундаментальной
дилеммой. С одной стороны, было бы *очень* здорово сказать, что ты хочешь и не
переживать, как это сделается. С другой стороны это может привести к неприемлемо
низкой производительности. Может понадобится спуститься к менее понятным или
идиоматичным практикам, чтобы добиться лучшей производительность. Или может вы
брезгливо отдерните руки от высокоуровневого языка и решите раскошелиться на
реализацию на менее приторно-сладком *небезопасном* языке.

Еще хуже, если вы хотите иметь дело напрямую с операционной системой, вам
*придется* разговаривать на небезопасном языке: *"C"*. "C" вездесущ и неизбежен.
Это лингва-франка мира программирования. Даже все безопасные языки на самом деле
используют интерфейсы "C" для общения с глобальным миром! Как бы вы ни хотели,
как только ваша программа начинает взаимодействовать с "C", она перестает быть
безопасной.

Имея это ввиду, надо сказать, что Rust *абсолютно* безопасный язык
программирования.

Ну, вообще-то, у Rust *есть* безопасный язык программирования. Отступим немного.

Rust можно считать состоящим из двух языков программирования: *Безопасный Rust*
и *Небезопасный Rust*. Безопасный Rust на самом деле абсолютно безопасен.
Небезопасный Rust, как ни удивительно, на самом деле абсолютно *не* безопасен.
Небезопасный Rust позволяет делать вам разные сумасшедшие небезопасные вещи.

Безопасный Rust это и *есть* язык программирования Rust. Если вы пишите все на
Безопасном Rust, вам никогда не придется волноваться о безопасности типов или
безопасности-памяти. Вы никогда не испытаете проблем с нулевым или висячим
указателем или всей этой чушью с неопределенным поведением.

*Это офигенно круто.*

Стандартная библиотека дает вам достаточно утилит из-коробки, позволяющих
написать высоко-производительные приложения или библиотеки на чистом
идеологически-правильном Безопасном Rust.

Но может вам захочется поговорить на другом языке. Может вы пишите низко-
уровневые абстракции, не включенные в стандартную библиотеку. Может вы просто
*пишите* стандартную библиотеку (которая написана полностью на Rust). Может вам
нужно сделать то, что не понимает система типов, и просто *программку из
чертовских бит*. Может вам нужен Небезопасный Rust.

Небезопасный Rust это тот же Безопасный Rust с теми же правилами и семантикой.
Но он позволяет делать вам некоторые дополнительные штуки, которые Определенно
Не Безопасны.

Единственные отличия Небезопасного Rust в том, что вы можете:

* Разыменовывать сырые указатели
* Вызывать `unsafe` функции (включая функции на "С", встроенные функции, 
сырое распределение)
* Реализовывать `unsafe` типажи 
* Изменять статику

Вот и все. Причиной по которой эти операции понижены до Небезопасных является
то, что злоупотребление ими вызывает еще более Неопределенное Поведение. Вызов
Неопределенного поведения дает компилятору все права самовольно делать плохие
вещи с вашей программой. Вы определенно *не* должны вызывать Неопределенное
поведение.

В отличие от C, Неопределенное поведение довольно ограничено в области Rust. Все
о чем заботиться ядро языка - предотвращение следующего:

* Разыменование нулевых или висячих указателей
* Чтение [неинициализированной памяти]
* Нарушение [правил выдачи псевдонимов указателям]
* Создание неверных примитивных значений:
    * висячих/нулевых ссылок
    * `bool`, который не 0 и не 1
    * неопределенных вариантов `enum`
    * `char` вне границ [0x0, 0xD7FF] и [0xE000, 0x10FFFF]
    * Не-utf8 `str`
* Размотка в другой язык
* Вызов [гонок данных][race]

Вот и все. Это все случаи Неопределенного поведения применительно к Rust.
Конечно, небезопасные функции и типажи могут спокойно сами определять другие
ограничения, которые должны соблюдаться в программе для избежания
Неопределенного поведения. Однако смысл их все равно сведется к одной из проблем
выше. Некоторые дополнительные ограничения могут появиться из встроенных функций
компилятора, который делает предположения об оптимизации кода.

С другой стороны Rust довольно либерально относится к некоторым сомнительным
операциям. Rust считает "безопасными":

* Дедлоки
* Иметь [состояние гонки][race]
* Утечка памяти
* Ошибка при вызове деструкторов
* Переполнение целых чисел
* Прерывание программы
* Удаление рабочей базы данных

Однако любая программа, которая делает эти вещи, наверняка неправильна. Rust
предоставляет много инструментов для избавления от этих штук, но эти проблемы и
так считаются нежизнеспособны, чтобы еще полностью их предотвратить.

[pointer aliasing rules]: references.html
[uninitialized memory]: uninitialized.html
[race]: races.html
