% repr(Rust)

В первую очередь все типы имеют выравнивание, указываемое в байтах. Выравнивание типа определяет в каких адресах разрешается хранить значения. Значение, имеющее выравнивание `n`, должно храниться по адресу кратному `n`. То есть выравнивание 2 означает, что его можно хранить только по четным адресам, а 1 означает, что по любым. Выравнивание всегда больше или равно 1, и всегда является степенью 2. Большинство примитивов выравнены по своему размеру, хотя это очень платформно-специфичное поведение. В частности, на x86 `u64` и `f64` могут быть выравнены только по 32 бита.

Размер типа должен всегда складываться из его выравнивания. Это гарантирует, что массив типов может всегда быть проиндексирован посредством смещения на величину, кратную 
размера типа. Имейте ввиду, что размер и выравнивание типа могут быть неизвестны статически в случае [типов динамического размера][dst].

Rust дает вам следующие способы для размещения составных данные:

* struct (именованные создаваемые типы)
* tuple (анонимные создаваемые типы)
* array (гомогенные создаваемые типы)
* enum (именованные типы-суммы)

Enum называется *C-подобным* если ни у одного из его вариантов нет связанных данных.

Составные структуры будут иметь выравнивание, равное максимуму из выравниваний их полей. Вследствие этого Rust добавит вставки (padding), где это необходимо, чтобы гарантировать, что все поля правильно выравнены и общий размер типа соответствует этому выравниванию. Например:

```rust
struct A {
    a: u8,
    b: u32,
    c: u16,
}
```

будет выравнено по 32-бита в архитектуре, которая выравнивает эти примитивы по соответствующему размеру. Таким образом полная struct будет иметь размер, кратный 32-бит. Вероятно, все станет таким:

```rust
struct A {
    a: u8,
    _pad1: [u8; 3], // для выравнивания `b`
    b: u32,
    c: u16,
    _pad2: [u8; 2], // для того чтобы сделать размер равным 4
}
```

Для этих типов *нет косвенности*; все данные хранятся внутри структуры, также как было бы и в "C". За исключением массивов (которые плотно упакованы и имеют порядок), положение данных, по умолчанию, не опредлено в Rust. Возьмем два определения struct:

```rust
struct A {
    a: i32,
    b: u64,
}

struct B {
    a: i32,
    b: u64,
}
```

Rust *гарантирует*, что два экземпляра А будут иметь одинаковое расположение данных. Но Rust *не гарантирует* на данный момент, что экземпляр A будет иметь такой же порядок или паддинг, как и экземпляр B, хотя на практике нет никакого основания предполагать, почему он должен отличаться.

Возьмем A и B как здесь написано, кажется, что все ясно, но другие особенности Rust используют более сложные игры с расположением данных внутри языка.

Например, считаем, что есть такая struct:

```rust
struct Foo<T, U> {
    count: u16,
    data1: T,
    data2: U,
}
```

Подразумеваем мономорфизацию `Foo<u32, u16>` и `Foo<u16, u32>`. Если Rust расположит поля в указанном порядке, мы ожидаем, что он набьет вставками (padding) значения в struct для того, чтобы удовлетворить требования выравнивания. Поэтому, если Rust не переопределит порядок полей, мы ожидаем, что он выработает следующее:

```rust,ignore
struct Foo<u16, u32> {
    count: u16,
    data1: u16,
    data2: u32,
}

struct Foo<u32, u16> {
    count: u16,
    _pad1: u16,
    data1: u32,
    data2: u16,
    _pad2: u16,
}
```

В последнем случае место просто напрасно расходуется. Оптимальное использование места, таким образом, требует, чтобы у разнх мономорфизаций *менялся порядок полей*.

**Внимание: это гипотетическая оптимизация, которая еще не релизована в Rust 1.0**

Перечисления делают этот анализ даже еще сложнее. Наивно предполагам, что enum:

```rust
enum Foo {
    A(u32),
    B(u64),
    C(u8),
}
```

будет расположен так:

```rust
struct FooRepr {
    data: u64, // здесь или u64, u32 или u8 - зависит от `tag`
    tag: u8,   // 0 = A, 1 = B, 2 = C
}
```

И на самом деле почти так будет все расположено в памяти в общем случае (размер данных и позиция `tag`).

Но есть случаи, в которых такое представление является неэффективным. Классический вариант - "оптимизация нулевого указателя" Rust: enum, состоящий из одного варианта (например, `None`) и (возможно вложенного) варианта с ненулевым указателем (например `&T`) делают таг необязательным, потому что значение нулевого указателя может безопасно означать, что выбран первый вариант (в данном примере, `None`). Конечный результат - например, будет таким `size_of::<Option<&T>>() == size_of::<&T>()`.

Много типов в Rust, которые являются или содержат ненулевые указатели, такие как `Box<T>`, `Vec<T>`, `String`, `&T` и `&mut T`. По аналогии, можно представить, как вложенные  enumы объединяют свои теги в одно значение, так как по определению известно, что у них ограниченный набор валидных значений. В принципе enumы могут использовать довольно сложные алгоритмы для кэширования битов всех вложенных типов в специально ограничвающие их представление. Именно поэтому *особенно* целесообразно нам представляется сегодня оставить расположение в памяти enum неопредленным.

[dst]: exotic-sizes.html#dynamically-sized-types-dsts
