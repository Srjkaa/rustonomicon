% Ссылки

В этой секции дается высокоуровневый взгляд на модель памяти, которой должны
соответствовать *все* программы на Rust. Безопасный код статически проверяется
на соответствие этой модели анализатором заимствований. Небезопасный код может
выходить за рамки анализатора заимствований, соответствуя этой модели.
Анализатор заимствований можно расширить, позволив большему количеству программ
компилироваться, пока они удовлетворяют фундаментальной модели.

Существует два типа ссылок:

* Общая ссылка: `&`
* Изменяемая ссылка: `&mut`

Которые подчиняются следующим правилам:

* Ссылки не могут пережить то, на что ссылаются
* Изменяемой ссылке нельзя присвоить псевдоним

Вот и все. Вот и все модель. Конечно, нам надо определить, что означает
*присвоить псевдоним*. Чтобы это сделать, мы должны определить значения *путей*
и *живучести*.


**Внимание: Идущая дальше модель считается сомнительной и имеет проблемы. Она 
нормальна для объяснения модели, но не в состоянии охватить желаемую семантику. 
Оставим ее так для объяснения значений, дающихся дальше в этой главе. Она 
существенно поменяется в будущем. TODO: сделай это.**


# Пути

Если бы у Rust были только значения (без указателей), тогда каждым значением
владела бы одна переменная или составная структура. Из этого мы выводим *дерево*
владения. Стек сам по себе является корнем дерева, а каждая переменная его
прямой ребенок. Каждый прямой ребенок переменной будет его полем (если они
будут) и так далее.

С этой точки зрения, каждому значения в Rust соответствует уникальный *путь* по
дереву владения. Особый интерес представляют *предки* и *потомки*: если `x`
владеет `y`, то `x` является предком `y`, а `y` потомком `x`. Заметьте, что это
включительное отношение: `x` является предком и потомком самого себя.

Мы можем определить ссылки как просто *названия* для путей. Когда вы создаете
ссылку, вы заявляете, что путь владения существует по этому адресу в памяти.

К несчастью, много данных не живут на стеке, а мы должны это учитывать. Глобалы
и локальные переменные потоков достаточно просты, и их можно разместить на дне
стека в модели (хотя мы должны быть осторожны с изменяемыми глобалами). Данные в
куче обнажают другие проблемы.

Если бы единственным, что у Rust было бы в куче, это данные, уникально владеемые
указателем из стека, то мы могли бы просто трактовать такой указатель как
структуру, которая владеет значением в куче. Box, Vec, String, и HashMap
являются примерами типов, уникально владеющими данными из кучи.

К сожалению, данные из кучи не *всегда* уникально владеемы. Rc, например,
представляет собой вариант обозначения *общего* владения. Общее владение
значением обозначает, что есть больше одного пути к нему. Значение, у
которого больше одного пути к нему, ограничивает то, что можно с ним сделать.

Итак, только общие ссылки могут быть созданы к неуникальным путям. Однако
механизмы, обеспечивающие взаимное исключение, могут временно обозначить  Одного
Настоящего Владельца, определив уникальный путь к этому значению (и, таким
образом, к его детям). Если это получится, значение можно будет изменять. В
частности, можно создать изменяемую ссылку.

Наиболее распространенным способом является установления такого пути через
*внутреннюю изменяемость*, которая отличается от *наследуемой изменяемость*,
используемой обычно везде в Rust. Cell, RefCell, Mutex и RWLock - это все
примеры типов с внутренней изменчивостью. Эти типы предоставляют эксклюзивный
доступ через ограничения, используемые средой исполнения.

Интересным случаем этого является Rc сам по себе: если у Rc счетчик ссылок равен
1, то RC можно безопасно изменять и даже перемещать его внутренние значения.
Помните, однако, что счетчик ссылок сам по себе использует внутреннюю
изменяемость.

Чтобы правильно взаимодействовать с системой типов, которая позволяет переменным
или полям структуры иметь внутреннюю изменяемость, она должна быть обернута в
UnsafeCell. Что само по себе не делает безопасным выполнение операция по
внутренней изменяемости значений. Вы сами должны гарантировать, что обеспечите
взаимное исключение.




# Живучесть

Внимание: Живучесть - это не то же самое, что и *время жизни*, которое объясняется детально в следующей секции этой главы.

Грубо говоря, ссылка *жива* в какой-то момент в программе, если ее можно
разыменовать. Общие ссылки всегда живы, даже если они буквально недостижимы
(например, они живут в освобожденной или утекшей памяти). Изменяемые ссылки могут
быть достижимы, но не быть *живыми* во время процесса *перезаимствования*.

Изменяемая ссылка может быть перезаимствованна или в общую или в изменяемую
ссылку на один из своих потомков. Перезаимствованная ссылка оживет заново, после
того, как у всех перезаимствованных производных от нее истечет время жизни.
Например, изменяемая ссылка может быть перезаимствованна полем того объекта, на
который она указывает:

```rust
let x = &mut (1, 2);
{
    // перезаимствование x под-полем
    let y = &mut x.0;
    // y теперь жива, а x нет
    *y = 3;
}
// y выходит из области видимости, поэтому x опять жива
*x = (5, 7);
```

Разрешается также передавать заимствование *несколькими* изменяемыми ссылками,
если они *не пересекаются*: каждая ссылка не является предком другой. Rust
позволяет явно делать это непересекающимся полям структуры, потому что
их разделение может быть статически доказано:

```rust
let x = &mut (1, 2);
{
    // перезаимствование x двум непересекающимся под-полям
    let y = &mut x.0;
    let z = &mut x.1;

    // y и z живы, но x нет
    *y = 3;
    *z = 4;
}
// y и z выходят из области видимости, поэтому x опять жива
*x = (5, 7);
```

Однако, часто случается, что Rust недостаточно умен, чтобы доказать что
множественное заимствование не пересекается. *Это не означает, что
фундаментально неправильно делать такое заимствование*, просто Rust не настолько
умен, как вам бы хотелось.

Для упрощения, мы можем создать модель, в которой переменные это обманные типы
ссылок: *владеющие* ссылки. Владеющие ссылки обладают похожей семантикой с
изменяемыми ссылками: их можно перезаимствовать наподобие изменяемых и общих
ссылок, что прекращает их жизнь. Живые владеющие ссылки обладают уникальным
свойством, из них можно переместить (хотя из изменяемых ссылок *можно*
выгрузить). Эта сила дается только *живым* владеющим ссылкам, потому что
перемещение того, на что они указывают, сделало бы все внешние ссылки
преждевременно недействительными.

Благодаря локальному статическому анализу несоответствующих изменений, только
переменные, помеченные `mut` могут быть заимствованны изменяемыми.

Интересно отметить, что Box ведет себя также как владеющая ссылка. То, на что он
указывает, можно переместить, и Rust достаточно понимает его, чтобы рассуждать о
пути к нему, как об обычной переменной.




# Присвоение псевдонимов

With liveness and paths defined, we can now properly define *aliasing*:

**A mutable reference is aliased if there exists another live reference to one
of its ancestors or descendants.**

(If you prefer, you may also say the two live references alias *each other*.
This has no semantic consequences, but is probably a more useful notion when
verifying the soundness of a construct.)

That's it. Super simple right? Except for the fact that it took us two pages to
define all of the terms in that definition. You know: Super. Simple.

Actually it's a bit more complicated than that. In addition to references, Rust
has *raw pointers*: `*const T` and `*mut T`. Raw pointers have no inherent
ownership or aliasing semantics. As a result, Rust makes absolutely no effort to
track that they are used correctly, and they are wildly unsafe.

**It is an open question to what degree raw pointers have alias semantics.
However it is important for these definitions to be sound that the existence of
a raw pointer does not imply some kind of live path.**
