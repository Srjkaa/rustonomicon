% Как взаимодействуют Безопасный и Небезопасный код

Итак, какие отношения между Безопасным и Небезопасным Rust? Как они
взаимодействуют?

Rust моделирует разделение между Безопасным и Небезопасным Rust ключевым словом
`unsafe`, которое можно трактовать как *интерфейс внешних функций (foreign
function interface)* (FFI) между Безопасным и Небезопасным Rust. Это магия,
благодаря которой можно сказать, что Безопасный Rust - действительно безопасен:
вся работа со страшными небезопасными битами отводится исключительно FFI, *как в
любом другом безопасном языке*.

Но из-за того, что один язык, получается, входит в другой, их можно спокойно
смешивать, обозначая границы между ними ключевым словом `unsafe`. Не надо писать
заголовочные файлы, инициализировать среду исполнения или какую-либо другую
рутину по обработке FFI.

Сегодня есть несколько мест, где может появиться `unsafe` в Rust, которые грубо
можно разделить на две категории:

* У вас есть непроверенные контракты. Чтобы убедиться, что вы поняли что имеется
ввиду, я рекомендую писать `unsafe` в следующих случаях:     * Перед функциями
`unsafe` показывает, что ее вызывать небезопасно. Пользователи должны посмотреть
документацию, чтобы определить, что это значит, и написать `unsafe`, чтобы
подтвердить, что они знают об опасности.     * Перед объявлением типажей
`unsafe` показывает, что *реализация* типажа является небезопасной операцией,
потому что у него есть контракты, которым другой небезопасный код имеет право
слепо доверять. (Больше об этом ниже.)

* Я заявляю, в меру своих знаний, что придерживался непроверенным контрактов:
* В реализации типажей `unsafe` показывает, что соблюдается контракт типажа
`unsafe`.     * В блоках `unsafe` показывает, что любая работа с небезопасными
операциями должна обрабатываться внутри, и, следовательно, родительская функция
безопасна.

Также есть флаг `#[unsafe_no_drop_flag]`, который являются особым случаем,
присутствующим по историческим причинам и находящимся на пути к выпиливанию.
Смотри раздел [drop flags] для уточнения.

Примеры небезопасных функций:

* `slice::get_unchecked` выполняет непроверенное индексирование, позволяющее
свободно нарушить безопасность памяти. * каждый сырой указатель на тип
фиксированного размера обладает внутренним методом `offset`, который вызывает
Неопределенное Поведение, если находится "вне границ", определяемых LLVM. *
`mem::transmute` интерпретирует значение полученного типа по-другому, самовольно
обходя безопасность типов. (смотри [conversions] для уточнения) * Все функции
FFI являются `unsafe`, потому что могут делать произвольные вещи. C является
очевидным виновником этого, но вообще-то любой язык может сделать что-то, от
чего Rust будет не в восторге.

В Rust 1.0 есть ровно два небезопасных типажа:

* `Send` - это маркерный типаж (у него нет своего API), который обещает, что его
* `реализации можно безопасно посылать (перемещать) в другой поток. Sync` - это
* `маркерный типаж, который обещает, что потоки могут безопасно делить его
* `реализацию между собой через общую ссылку на него.

Необходимость в небезопасных типаж кроется в основных свойствах безопасного
кода:

**Каким бы убогим ни был Безопасный код, он не сможет вызвать Неопределенное
**поведение.

Это означает, что Небезопасный Rust, **королевский авангард Неопределенного
поведения**, *супер параноидально* относится к общему безопасному коду. Объясняя
яснее, Небезопасный Rust доверяет абсолютно конкретному безопасному коду.
Остальной код вырождается в бесконечные спирали параноидального отчаяния для
него. В частности, обычно нормальным считается доверять корректности стандартной
библиотеки. `std` - это полезное расширение языка, вам, действительно, следует
доверять ему. Если `std` нарушает свои гарантии, тогда, возможно, это ошибка
языка.

Тем не менее, лучше минимизировать напрасные надежды на железобетонность
безопасного кода. Ошибки случаются! Конечно, я должен подтвердить, что это
только беспокойство за Небезопасный код. Безопасный код может слепо верить
всему, что не нарушает безопасность памяти.

С другой стороны, безопасные типажи могут свободно объявлять произвольные
контракты, именно, потому что их реализация безопасна, небезопасный код же не
может доверять тому, что эти контракты будут на самом деле соблюдаться. Это
отличается от какого-то конкретного случая, потому что *любой человек* может
реализовать интерфейс, как он хочет. В этом и состоит фундаментальная разница,
доверять ли правильности конкретного участка кода или доверять правильности
*любого кода, который будет когда либо написан*.

Например, в Rust есть типажи `PartialOrd` и `Ord`, нужные для того, чтобы можно
было отличить типы, которые можно "только" сравнивать, от тех, которые в
действительности поддерживают упорядочивание. В большинстве своем, каждое API,
которое хочет работать со сравнимыми данными, хочет иметь `Ord`. Например,
упорядоченный словарь BTreeMap *не имеет никакого смысла* создавать для частично
упорядоченных данных. Если вы объявите, что тип реализует `Ord`, но не
предоставите данные в правильном порядке, BTreeMap *сядет в лужу* и начнет
делать с собой разные плохие вещи. Вставленные данные будет уже невозможно
найти!

Но это еще нормально. BTreeMap безопасен, поэтому он гарантирует, что даже если
вы дадите ему полностью несортированную реализацию, он будет все равно делать
что-то *безопасное*. Вы не начнете читать неинициализированную или невыделенную
память. На самом деле, BTreeMap не потеряет даже ваши данные. После его
удаления, все деструкторы будут вызваны успешно! Ура!

Однако BTreeMap реализован с использованием маленькой щепотки Небезопасного Rust
(как и большинство коллекций). Это означает - не всегда правдиво будет
утверждать, что реализация плохого порядка заставит вести себя BTreeMap
безопасно. BTreeMap не должен полагаться на порядок, *ставя под угрозу
безопасность*. Порядок предоставляется безопасным кодом, а безопасность это не
то, за соблюдение чего отвечает безопасный код.

Но правда было бы здорово, если бы небезопасный код мог бы в *каких-нибудь
местах* доверять контрактам типажа? Эта проблема, которой занимаются
небезопасные типажи: помечая небезопасность реализации *самого типажа*,
небезопасный код может доверять реализациям контракта типажа. Хотя она может и
не быть правильной во всех произвольных случаях.

Например, имея гипотетический типаж UnsafeOrd, технически будет правильна такая
реализация:

```rust
# use std::cmp::Ordering;
# struct MyType;
# unsafe trait UnsafeOrd { fn cmp(&self, other: &Self) -> Ordering; }
unsafe impl UnsafeOrd for MyType {
    fn cmp(&self, other: &Self) -> Ordering {
        Ordering::Equal
    }
}
```

Но возможно это не та реализация, которая вам нужна.

Rust has traditionally avoided making traits unsafe because it makes Unsafe
pervasive, which is not desirable. The reason Send and Sync are unsafe is because thread
safety is a *fundamental property* that unsafe code cannot possibly hope to defend
against in the same way it would defend against a bad Ord implementation. The
only way to possibly defend against thread-unsafety would be to *not use
threading at all*. Making every load and store atomic isn't even sufficient,
because it's possible for complex invariants to exist between disjoint locations
in memory. For instance, the pointer and capacity of a Vec must be in sync.

Even concurrent paradigms that are traditionally regarded as Totally Safe like
message passing implicitly rely on some notion of thread safety -- are you
really message-passing if you pass a pointer? Send and Sync therefore require
some fundamental level of trust that Safe code can't provide, so they must be
unsafe to implement. To help obviate the pervasive unsafety that this would
introduce, Send (resp. Sync) is automatically derived for all types composed only
of Send (resp. Sync) values. 99% of types are Send and Sync, and 99% of those
never actually say it (the remaining 1% is overwhelmingly synchronization
primitives).




[drop flags]: drop-flags.html
[conversions]: conversions.html
